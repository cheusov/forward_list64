/*
 * Created by Aleksey Cheusov <vle@gmx.net>
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining
 * a copy of the software and accompanying documentation covered by this license
 * (the “Software”) to use, reproduce, display, distribute, execute, and transmit
 * the Software, and to prepare derivative works of the Software, and to permit
 * third-parties to whom the Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must be
 * included in all copies of the Software, in whole or in part, and all derivative
 * works of the Software, unless such copies or derivative works are solely in
 * the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
 * A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
 * LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <cstdint>
#include <iostream>
#include <cassert>

namespace __forward_list64_impl {
    template<typename T>
    struct type_size_t {
        static const int type_size = sizeof(T[2]) / 2;
    };

    template<std::size_t N>
    struct template_positive {
        static const std::size_t positive = N;
    };

    template<>
    struct template_positive<0> {
        static const std::size_t positive = 1;
    };

    template<typename T, int N, int P>
    struct alignas(64) aligned_list_item {
        static constexpr std::size_t max_count = template_positive<(64 - P) / N>::positive;
        static constexpr std::uintptr_t item_count_mask = 63;
        static constexpr std::uintptr_t pointer_mask = ~item_count_mask;

        std::uintptr_t m_next;
        T m_items[max_count];
//private:
//       char _[64 - P - (64 - P) / N * N]; // padding up to 64 bytes
    };

    template<typename T>
    struct unaligned_list_item {
        static constexpr std::size_t max_count = 1;
        static constexpr std::uintptr_t item_count_mask = sizeof(std::uintptr_t) - 1;
        static constexpr std::uintptr_t pointer_mask = ~item_count_mask;

        std::uintptr_t m_next;
        T m_items[1];
    };

    template<typename T, int N, int P>
    struct underlying_list_item : unaligned_list_item<T> {
    };

    template<typename T, int P>
    struct underlying_list_item<T, 1, P> : aligned_list_item<T, 1, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 2, P> : aligned_list_item<T, 2, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 3, P> : aligned_list_item<T, 3, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 4, P> : aligned_list_item<T, 4, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 5, P> : aligned_list_item<T, 5, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 6, P> : aligned_list_item<T, 6, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 7, P> : aligned_list_item<T, 7, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 8, P> : aligned_list_item<T, 8, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 9, P> : aligned_list_item<T, 9, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 10, P> : aligned_list_item<T, 10, P> {
    };

    template<typename T, int P>
    struct underlying_list_item<T, 11, P> : aligned_list_item<T, 11, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 12, P> : aligned_list_item<T, 12, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 13, P> : aligned_list_item<T, 13, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 14, P> : aligned_list_item<T, 14, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 15, P> : aligned_list_item<T, 15, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 16, P> : aligned_list_item<T, 16, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 17, P> : aligned_list_item<T, 17, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 18, P> : aligned_list_item<T, 18, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 19, P> : aligned_list_item<T, 19, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 20, P> : aligned_list_item<T, 20, P> {
    };

    template<typename T, int P>
    struct underlying_list_item<T, 21, P> : aligned_list_item<T, 21, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 22, P> : aligned_list_item<T, 22, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 23, P> : aligned_list_item<T, 23, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 24, P> : aligned_list_item<T, 24, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 25, P> : aligned_list_item<T, 25, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 26, P> : aligned_list_item<T, 26, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 27, P> : aligned_list_item<T, 27, P> {
    };
    template<typename T, int P>
    struct underlying_list_item<T, 28, P> : aligned_list_item<T, 28, P> {
    };
    template<typename T>

    struct underlying_list_item<T, 29, 4> : aligned_list_item<T, 29, 4> {
    };
    template<typename T>
    struct underlying_list_item<T, 30, 4> : aligned_list_item<T, 30, 4> {
    };

    template<typename T>
    struct list_item : underlying_list_item<T, type_size_t<T>::type_size, sizeof(std::uintptr_t)> {
    };
};

template <typename T, typename Allocator = std::allocator<T>>
class forward_list64 {
private:
    std::uintptr_t m_first_block = 0;

    typedef __forward_list64_impl::list_item<T> list_node_t;

    // TODO: allocator is not used yet
    Allocator m_allocator;

    inline static int get_item_count(std::uintptr_t value) {
        return value & list_node_t::item_count_mask;
    }

    inline static list_node_t *get_node(std::uintptr_t value) {
        return reinterpret_cast<list_node_t *>(
            value & list_node_t::pointer_mask);
    }

public:
    typedef T                                                          value_type;
    typedef Allocator                                                  allocator_type;
    typedef typename std::allocator_traits<Allocator>::size_type       size_type;
    typedef typename std::allocator_traits<Allocator>::difference_type difference_type;
    typedef value_type&                                                reference;
    typedef const value_type&                                          const_reference;
    typedef typename std::allocator_traits<Allocator>::pointer         pointer;
    typedef typename std::allocator_traits<Allocator>::const_pointer   const_pointer;

public:
    class const_iterator {
    private:
        list_node_t *block_ptr;
        T *value_ptr;
        T *value_end;

        typedef forward_list64<T, Allocator> container_type;

    public:
        typedef std::forward_iterator_tag iterator_category;
        typedef std::size_t size_type;
        typedef T value_type;
        typedef std::ptrdiff_t difference_type;
        typedef value_type &reference;
        typedef const value_type &const_reference;
        typedef T *pointer;
        typedef const T *const_pointer;

        const_iterator(const const_iterator &value);

        explicit const_iterator(std::uintptr_t block);

        reference operator*() const;

        const_pointer operator->() const;

        const_iterator &operator++();

        const_iterator operator++(int);

        bool operator==(const const_iterator &it) const;

        bool operator!=(const const_iterator &it) const;
    };

    class iterator {
    private:
        list_node_t *block_ptr;
        T *value_ptr;
        T *value_end;

        typedef forward_list64<T, Allocator> container_type;

    public:
        typedef std::forward_iterator_tag iterator_category;
        typedef std::size_t               size_type;
        typedef T                         value_type;
        typedef std::ptrdiff_t            difference_type;
        typedef value_type&               reference;
        typedef const value_type&         const_reference;
        typedef T *                       pointer;
        typedef const T *                 const_pointer;

        iterator(const iterator& value);

        explicit iterator(std::uintptr_t block);

        reference operator * ();

        pointer operator -> ();

        iterator& operator ++ ();

        iterator operator ++ (int);

        bool operator == (const iterator& it) const;

        bool operator != (const iterator& it) const;
    };

public:
    explicit forward_list64();
    explicit forward_list64(const Allocator& alloc);
    explicit forward_list64(size_type _count, const Allocator& alloc = Allocator());
    explicit forward_list64(size_type count, const T& value, const Allocator& alloc = Allocator());
    template <class InputIt>
    explicit forward_list64(
        InputIt first, InputIt last,
        const Allocator& alloc = Allocator());
    forward_list64(const forward_list64& other);
    explicit forward_list64(const forward_list64& other, const Allocator& alloc);
    forward_list64(forward_list64&& other) noexcept;
    forward_list64(std::initializer_list<T> init,
        const Allocator& alloc = Allocator());

    ~forward_list64();

    forward_list64& operator = (const forward_list64& other);
    forward_list64& operator = (forward_list64&& other) noexcept;
    forward_list64& operator = (std::initializer_list<T> init);

    void assign(size_type count, const T& value);
    void assign(std::initializer_list<T> init);
    template <class InputIt>
    void assign(InputIt first, InputIt last);

    void push_front(const T& value);

    reference front();
    const_reference front() const;

    const_iterator begin() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator end() const noexcept;
    const_iterator cend() const noexcept;
    iterator begin() noexcept;
    iterator end() noexcept;

    [[nodiscard]] bool empty() const noexcept;

    void pop_front();

    void clear() noexcept;

    inline void swap(forward_list64& other) noexcept;

    allocator_type get_allocator() const noexcept;
private:
    void copy(const forward_list64& other);
};

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64() = default;

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64(const Allocator& alloc)
    : m_allocator(alloc) {
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64(
        size_type count,
        const T& value,
        const Allocator& alloc)
        : m_first_block(0), m_allocator(alloc)
{
    assign(count, value);
}

template <typename T, typename Allocator>
void forward_list64<T, Allocator>::assign(
        size_type _count,
        const T& value)
{
    clear();

    std::uintptr_t last_block = 0;
    long long count = _count;
    while (count > 0) {
        auto block = new list_node_t();
        block->m_next = last_block;

        int item_count;
        if (count > list_node_t::max_count)
            item_count = list_node_t::max_count;
        else
            item_count = int(count);

        for (int i = 0; i < item_count; ++i)
            block->m_items[i] = value;

        last_block = (std::uintptr_t(block) | item_count);

        count -= list_node_t::max_count;
    }
    m_first_block = last_block;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64(size_type _count, const Allocator& alloc) :
        forward_list64<T, Allocator>::forward_list64(_count, T(), alloc) {
}

template <typename T, typename Allocator>
template <class InputIt>
forward_list64<T, Allocator>::forward_list64(
        InputIt first, InputIt last, const Allocator& alloc)
        : m_first_block(0), m_allocator(alloc)
{
    assign(first, last);
}

template <typename T, typename Allocator>
template <class InputIt>
void forward_list64<T, Allocator>::assign(
        InputIt first, InputIt last)
{
    clear();

    // TODO: optimize performance
    forward_list64<T, Allocator> temp;
    for (; first != last; ++first) {
        temp.push_front(*first);
    }

    for (auto value: temp) {
        push_front(value);
    }
}

template <typename T, typename Allocator>
void forward_list64<T, Allocator>::assign(
        std::initializer_list<T> init)
{
    assign(init.begin(), init.end());
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64(const forward_list64& other)
: forward_list64(other, Allocator()) {
}

template <typename T, typename Allocator>
void forward_list64<T, Allocator>::copy(
        const forward_list64<T, Allocator>& other)
{
    std::uintptr_t old_block = other.m_first_block;
    std::uintptr_t *last_new_block = &m_first_block;
    while (old_block) {
        auto old_block_ptr = get_node(old_block);
        auto old_item_count = get_item_count(old_block);

        auto new_block_ptr = new list_node_t(*old_block_ptr);
        *last_new_block = std::uintptr_t(new_block_ptr) | old_item_count;
        last_new_block = &old_block_ptr->m_next;

        old_block = old_block_ptr->m_next;
    }
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64(const forward_list64& other, const Allocator& alloc )
    : m_first_block(0), m_allocator(alloc)
{
    copy(other);
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64(forward_list64&& other) noexcept {
    std::swap(m_allocator, other.m_allocator);
    m_first_block = other.m_first_block;
    other.m_first_block = 0;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::forward_list64(
        std::initializer_list<T> init,
        const Allocator& alloc)
        : forward_list64(init.begin(), init.end(), alloc) {
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::~forward_list64() {
    clear();
}

template <typename T, typename Allocator>
void forward_list64<T, Allocator>::push_front(const T& value) {
    int items_in_block;
    list_node_t *first_block_ptr;

    if (!m_first_block) [[unlikely]] {
        first_block_ptr = new list_node_t();
        first_block_ptr->m_items[0] = value;
        first_block_ptr->m_next = 0;
        m_first_block = reinterpret_cast<std::uintptr_t> (first_block_ptr) | 1;
        return;
    }

    items_in_block = get_item_count(m_first_block);
    first_block_ptr = get_node(m_first_block);
    if (items_in_block == list_node_t::max_count) [[unlikely]] {
        auto *new_first_block = new list_node_t();
        new_first_block->m_next = m_first_block;
        new_first_block->m_items[0] = value;
        m_first_block = reinterpret_cast<uintptr_t>(new_first_block) | 1;
    } else {
        first_block_ptr->m_items[items_in_block++] = value;
        ++m_first_block;
    }
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::const_iterator
        forward_list64<T, Allocator>::begin() const noexcept {
    return cbegin();
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::const_iterator
        forward_list64<T, Allocator>::cbegin() const noexcept {
    return const_iterator(m_first_block);
}

template <typename T, typename Allocator>
inline typename forward_list64<T, Allocator>::const_iterator
forward_list64<T, Allocator>::end() const noexcept {
    return cend();
}

template <typename T, typename Allocator>
inline typename forward_list64<T, Allocator>::const_iterator
forward_list64<T, Allocator>::cend() const noexcept {
    return const_iterator(0);
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::iterator forward_list64<T, Allocator>::begin() noexcept {
    return iterator(m_first_block);
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::iterator forward_list64<T, Allocator>::end() noexcept {
    return iterator(0);
}

template <typename T, typename Allocator>
void forward_list64<T, Allocator>::clear() noexcept {
    auto block = get_node(m_first_block);
    while (block != nullptr) {
        auto next = get_node(block->m_next);
        delete block;
        block = next;
    }
    m_first_block = 0;
}

template <typename T, typename Allocator>
inline void forward_list64<T, Allocator>::swap(forward_list64<T, Allocator>& other) noexcept {
    std::swap(this->m_first_block, other.m_first_block);
    std::swap(this->m_allocator, other.m_allocator);
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::const_iterator::const_iterator(const const_iterator& value) {
    block_ptr = value.block_ptr;
    value_ptr = value.value_ptr;
    value_end = value.value_end;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::const_iterator::const_iterator(std::uintptr_t block) {
    int items_in_block = container_type::get_item_count(block);
    block_ptr = container_type::get_node(block);
    value_end = block_ptr->m_items - 1;
    value_ptr = value_end + items_in_block;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::reference
forward_list64<T, Allocator>::const_iterator::operator * () const {
    return *value_ptr;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::const_iterator::const_pointer
forward_list64<T, Allocator>::const_iterator::operator -> () const {
    return value_ptr;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::const_iterator&
forward_list64<T, Allocator>::const_iterator::operator ++ () {
    --value_ptr;
    if (value_ptr == value_end) {
        int items_in_block = container_type::get_item_count(block_ptr->m_next);
        block_ptr = container_type::get_node(block_ptr->m_next);
        value_end = block_ptr->m_items - 1;
        value_ptr = value_end + items_in_block;
    }
    return *this;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::const_iterator
forward_list64<T, Allocator>::const_iterator::operator ++ (int) {
    const_iterator temp(*this);
    ++(*this);
    return temp;
}

template <typename T, typename Allocator>
bool forward_list64<T, Allocator>::const_iterator::operator == (const const_iterator& it) const {
    return this->value_ptr == it.value_ptr;
}

template <typename T, typename Allocator>
bool forward_list64<T, Allocator>::const_iterator::operator != (const const_iterator& it) const {
    return this->value_ptr != it.value_ptr;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>&
forward_list64<T, Allocator>::operator = (
        const forward_list64<T, Allocator>& other)
{
    clear();
    copy(other);
    return *this;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>&
forward_list64<T, Allocator>::operator = (
        forward_list64<T, Allocator>&& other) noexcept
{
    clear();
    std::swap(m_allocator, other.m_allocator);
    m_first_block = other.m_first_block;
    other.m_first_block = 0;
    return *this;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>& forward_list64<T, Allocator>::operator = (
        std::initializer_list<T> init)
{
    clear();
    copy(init);
    return *this;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::iterator::iterator(const forward_list64<T, Allocator>::iterator& value) {
    block_ptr = value.block_ptr;
    value_ptr = value.value_ptr;
    value_end = value.value_end;
}

template <typename T, typename Allocator>
forward_list64<T, Allocator>::iterator::iterator(std::uintptr_t block) {
    int items_in_block = container_type::get_item_count(block);
    block_ptr = container_type::get_node(block);
    value_end = block_ptr->m_items - 1;
    value_ptr = value_end + items_in_block;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::reference
forward_list64<T, Allocator>::iterator::operator * () {
    return *value_ptr;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::iterator::pointer
forward_list64<T, Allocator>::iterator::operator -> () {
    return value_ptr;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::iterator&
forward_list64<T, Allocator>::iterator::iterator::operator ++ () {
    --value_ptr;
    if (value_ptr == value_end) {
        auto next = block_ptr->m_next;
        int items_in_block = container_type::get_item_count(next);
        block_ptr = container_type::get_node(next);
        value_end = block_ptr->m_items - 1;
        value_ptr = value_end + items_in_block;
    }
    return *this;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::iterator
forward_list64<T, Allocator>::iterator::operator ++ (int) {
    iterator temp(*this);
    ++(*this);
    return temp;
}

template <typename T, typename Allocator>
bool
forward_list64<T, Allocator>::iterator::operator == (const iterator& it) const {
    return this->value_ptr == it.value_ptr;
}

template <typename T, typename Allocator>
bool
forward_list64<T, Allocator>::iterator::operator != (const iterator& it) const {
    return this->value_ptr != it.value_ptr;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::allocator_type
forward_list64<T, Allocator>::get_allocator() const noexcept {
    return m_allocator;
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::reference
forward_list64<T, Allocator>::front() {
    int items_in_block = get_item_count(m_first_block);
    auto first_block_ptr = get_node(m_first_block);
    return first_block_ptr->m_items[items_in_block-1];
}

template <typename T, typename Allocator>
typename forward_list64<T, Allocator>::const_reference
forward_list64<T, Allocator>::front() const {
    int items_in_block = get_item_count(m_first_block);
    auto first_block_ptr = get_node(m_first_block);
    return first_block_ptr->m_items[items_in_block-1];
}

template <typename T, typename Allocator>
void forward_list64<T, Allocator>::pop_front() {
    int items_in_block = get_item_count(m_first_block);
    if (items_in_block == 1) {
        auto first_block_ptr = get_node(m_first_block);
        m_first_block = first_block_ptr->m_next;
        delete first_block_ptr;
    } else {
        --m_first_block;
    }
}

template <typename T, typename Allocator>
[[nodiscard]] bool
forward_list64<T, Allocator>::empty() const noexcept {
    return m_first_block == 0;
}

namespace std {

    template <typename T, typename Allocator>
    inline void swap(forward_list64<T, Allocator>& x, forward_list64<T, Allocator>& y) noexcept {
        x.swap(y);
    }

    template <class T, class Allocator>
    bool operator == ( const forward_list64<T, Allocator>& lhs,
                     const forward_list64<T, Allocator>& rhs ) {
        return lhs == rhs;
    }

    template <class T, class Allocator>
    bool operator != ( const forward_list64<T, Allocator>& lhs,
                       const forward_list64<T, Allocator>& rhs ) {
        return lhs != rhs;
    }

} // namespace std
