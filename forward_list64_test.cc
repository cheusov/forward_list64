/*
 * Created by Aleksey Cheusov <vle@gmx.net>
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining
 * a copy of the software and accompanying documentation covered by this license
 * (the “Software”) to use, reproduce, display, distribute, execute, and transmit
 * the Software, and to prepare derivative works of the Software, and to permit
 * third-parties to whom the Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must be
 * included in all copies of the Software, in whole or in part, and all derivative
 * works of the Software, unless such copies or derivative works are solely in
 * the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR
 * A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER
 * LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include <memory>
#include <iostream>
#include <forward_list>

#include "forward_list64.h"

template <typename T>
class forward_list64_test {
private:
    typedef forward_list64_test<T> self_type;

    forward_list64<T> list64;
    std::forward_list<T> list;

    void check(std::string message) {
        std::string list_items;
        for (const auto &item: list) {
            list_items += ' ';
            list_items += std::to_string(item);
        }

        std::string list64_items;
        for (const auto &item: list64) {
            list64_items += ' ';
            list64_items += std::to_string(item);
        }

        if (list64_items != list_items) {
            std::cerr << "list_items: " << list_items << '\n';
            std::cerr << "list64_items: " << list64_items << '\n';
            abort();
        }

        std::cerr << "ok\n";
    }

    template <typename ListType>
    void create_list(ListType &l, std::size_t n) {
        for (int i = 0; i < n; ++i) {
            l.push_front(10 + i);
        }
        for (auto it = l.cbegin(); it != l.cend(); ++it) {
            l.push_front(*it);
        }
    }

    template <typename ListType>
    void clear_list(ListType &l) {
        l.clear();
    }

    template <typename ListType>
    void create_N_default_items(ListType &l, std::size_t n) {
        ListType local_list(n);
        std::swap(local_list, l);
    }

    template <typename ListType>
    void create_list_of_5(ListType &l, std::size_t n) {
        ListType local_list(n, 5);
        std::swap(local_list, l);
    }

    template <typename ListType>
    void create_list_from_array(ListType &l) {
        static const int array[] = {
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                11, 12, 13, 14, 15, 16, 17, 18, 19, 20
        };
        ListType local_list(array, array + std::size(array));
        std::swap(local_list, l);
    }

    template <typename ListType>
    void copy(ListType &l) {
        ListType local_list(l);
        std::swap(local_list, l);
    }

    template <typename ListType>
    void move(ListType &l) {
        ListType temp;
        for (int i = 0; i < 100; i += 5) {
            temp.push_front(i);
        }
        ListType other_list(reinterpret_cast<ListType&&>(temp));
        l.swap(other_list);
    }

    template <typename ListType>
    void initializer_list(ListType &l) {
        ListType temp {
            10, 20, 30, 40, 50,
            11, 21, 31, 41, 51,
            12, 22, 32, 42, 52,
            13, 23, 33, 43, 53
        };
        l.swap(temp);
    }

    template <typename ListType>
    void assign(ListType &l) {
        ListType temp {
           10,20,30,40,50,
           11,21,31,41,51,
           12,22,32,42,52,
           13,23,33,43,53
        };
        l = temp;
    }

    template <typename ListType>
    void assign_move(ListType &l) {
        ListType temp {
            10, 20, 30, 40, 50,
            11, 21, 31, 41, 51,
            12, 22, 32, 42, 52,
            13, 23, 33, 43, 53
        };
        l.operator = (reinterpret_cast<ListType&&>(temp));
    }

    template <typename ListType>
    void assign_ilist(ListType &l) {
        l = {
                10, 20, 30, 40, 50,
                11, 21, 31, 41, 51,
                12, 22, 32, 42, 52,
                13, 23, 33, 43, 53
        };
    }

    template <typename ListType>
    void assign_method1(ListType &l) {
        l.assign(std::size_t(22), 90);
    }

    template <typename ListType>
    void assign_method2(ListType &l) {
        l.assign({
            10, 20, 30, 40, 50,
            11, 21, 31, 41, 51,
            12, 22, 32, 42, 52,
            13, 23, 33, 43, 53
        });
    }

    template <typename ListType>
    void assign_method3(ListType &l) {
        static const int array[] = {
                71, 72, 73, 74, 75,
                76, 77, 78, 79, 80,
                81, 82, 83, 84, 85,
                86, 87, 88, 89, 90
        };
        l.assign(array, array + std::size(array));
    }

    template <typename ListType>
    void front(ListType &l) {
        l.push_front(l.front());
    }

    template <typename ListType>
    void empty(ListType &l) {
        l.push_front(l.empty());
    }

    void check(
        std::string message,
        void (forward_list64_test::*func1)(std::forward_list<T>&),
        void (forward_list64_test::*func2)(forward_list64<T>&)
    ) {
        std::cerr << message << "... ";
        (this->*func1)(list);
        (this->*func2)(list64);
        check("ok");
    }

    void check(
        std::string message,
        std::size_t n,
        void (forward_list64_test::*func1)(std::forward_list<T>&, std::size_t n),
        void (forward_list64_test::*func2)(forward_list64<T>&, std::size_t n)
    ) {
        std::cerr << message << "... ";
        (this->*func1)(list, n);
        (this->*func2)(list64, n);
        check("ok");
    }

public:
    void test() {
        std::cerr << "sizeof element: " << sizeof(T) << '\n';

        for (std::size_t n: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 16, 40, 80} ) {
            check(
                "   .push_front " + std::to_string(n) + " times",
                n,
                &self_type::create_list, &self_type::create_list
            );
        }
        check(
            "   .clear",
            &self_type::clear_list, &self_type::clear_list
        );
        check(
            "   .empty",
            &self_type::empty, &self_type::empty
        );
        check(
            "   .constructor(IteratorT, IteratorT)",
            &self_type::create_list_from_array, &self_type::create_list_from_array
        );
        check(
            "   .constructor(const forward_list64 &)",
            &self_type::copy, &self_type::copy
        );
        check(
            "   .constructor(forward_list64 &&)",
            &self_type::move, &self_type::move
        );
        check(
            "   .constructor(std::initializer_list<T>)",
            &self_type::initializer_list, &self_type::initializer_list
        );
        check(
            "   .operator = (const forward_list64 &)",
            &self_type::assign, &self_type::assign
        );
        check(
            "   .operator = (forward_list64 &&)",
            &self_type::assign_move, &self_type::assign_move
        );
        check(
            "   .operator = (std::initializer_list<T>)",
            &self_type::assign_ilist, &self_type::assign_ilist
        );
        check(
            "   .assign(int, const T &)",
            &self_type::assign_method1, &self_type::assign_method1
        );
        check(
            "   .assign(std::initializer_list<T>)",
            &self_type::assign_method2, &self_type::assign_method2
        );
        check(
            "   .assign(IteratorT, IteratorT)",
            &self_type::assign_method3, &self_type::assign_method3
        );
        check(
            "   .front",
            &self_type::front, &self_type::front
        );

        for (std::size_t n = 0; n < 80; ++n) {
            check(
                "   .constructor(" + std::to_string(n) + ", const T&) and std::swap... ",
                n,
                &self_type::create_list_of_5, &self_type::create_list_of_5
            );
        }

        for (std::size_t n = 0; n < 80; ++n) {
            check(
                "   .constructor(" + std::to_string(n) + ")... ",
                n,
                &self_type::create_N_default_items, &self_type::create_N_default_items
            );
        }

        std::cerr << "   .pop_front... ";
        while (!list.empty()) {
            list.pop_front();
            list64.pop_front();
        }
        check("");

        // compilation test
        list.get_allocator();
        list64.get_allocator();
    }
};

int main(int argc, char **argv);
int main(int argc, char **argv)
{
    forward_list64_test<long long>().test();
    forward_list64_test<long>().test();
    forward_list64_test<int>().test();
    forward_list64_test<short>().test();
    forward_list64_test<int8_t>().test();

    auto ptr = std::shared_ptr<int>(new int(5));
}
